---
description: Funzione SQLSetStmtAttr
title: Funzione SQLSetStmtAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: reference
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: ae590b9ba8a01182f32928f874f0417b554f00a1
ms.sourcegitcommit: 33f0f190f962059826e002be165a2bef4f9e350c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/30/2021
ms.locfileid: "99191764"
---
# <a name="sqlsetstmtattr-function"></a>Funzione SQLSetStmtAttr
**Conformità**  
 Versione introdotta: ODBC 3,0 Standard Compliance: ISO 92  
  
 **Summary**  
 **SQLSetStmtAttr** imposta gli attributi correlati a un'istruzione.  
  
> [!NOTE]
>  Per ulteriori informazioni su ciò che Gestione driver esegue il mapping di questa funzione a quando un'applicazione ODBC *3. x* utilizza un driver ODBC *2. x* , vedere [mapping di funzioni di sostituzione per la compatibilità con le versioni precedenti delle applicazioni](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintassi  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argomenti  
 *StatementHandle*  
 Input Handle di istruzione.  
  
 *Attributo*  
 Input Opzione da impostare, elencata in "Commenti".  
  
 *ValuePtr*  
 Input Valore da associare all' *attributo*. A seconda del valore dell' *attributo*, *ValuePtr* sarà uno dei seguenti:  
  
-   Handle del descrittore ODBC.  
  
-   Valore SQLUINTEGER.  
  
-   Valore SQLULEN.  
  
-   Puntatore a uno dei seguenti elementi:  
  
    -   Stringa di caratteri con terminazione null.  
  
    -   Buffer binario.  
  
    -   Un valore o una matrice di tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Valore definito dal driver.  
  
 Se l'argomento dell' *attributo* è un valore specifico del driver, *ValuePtr* può essere un intero con segno.  
  
 *StringLength*  
 Input Se *attribute* è un attributo definito da ODBC e *ValuePtr* punta a una stringa di caratteri o a un buffer binario, questo argomento deve essere la lunghezza di \* *ValuePtr*. Se *attribute* è un attributo definito da ODBC e *ValuePtr* è un numero intero, *StringLength* viene ignorato.  
  
 Se *attribute* è un attributo definito dal driver, l'applicazione indica la natura dell'attributo a gestione driver impostando l'argomento *StringLength* . *StringLength* può avere i valori seguenti:  
  
-   Se *ValuePtr* è un puntatore a una stringa di caratteri, *StringLength* è la lunghezza della stringa o del SQL_NTS.  
  
-   Se *ValuePtr* è un puntatore a un buffer binario, l'applicazione inserisce il risultato della macro SQL_LEN_BINARY_ATTR (*length*) in *StringLength*. Questo inserisce un valore negativo in *StringLength*.  
  
-   Se *ValuePtr* è un puntatore a un valore diverso da una stringa di caratteri o una stringa binaria, il valore di *StringLength* deve essere SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiene un valore a lunghezza fissa, *StringLength* è SQL_IS_INTEGER o SQL_IS_UINTEGER, a seconda delle esigenze.  
  
## <a name="returns"></a>Restituisce  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostica  
 Quando **SQLSetStmtAttr** restituisce SQL_ERROR o SQL_SUCCESS_WITH_INFO, è possibile ottenere un valore SQLSTATE associato chiamando **SQLGetDiagRec** con *HandleType* di SQL_HANDLE_STMT e un *handle* di *statementHandle*. La tabella seguente elenca i valori SQLSTATE restituiti comunemente da **SQLSetStmtAttr** e ne illustra ognuno nel contesto di questa funzione; la notazione "(DM)" precede le descrizioni di SQLSTATE restituite da Gestione driver. Il codice restituito associato a ogni valore SQLSTATE è SQL_ERROR, a meno che non sia specificato diversamente.  
  
|SQLSTATE|Errore|Descrizione|  
|--------------|-----------|-----------------|  
|01000|Avviso generale|Messaggio informativo specifico del driver. (La funzione restituisce SQL_SUCCESS_WITH_INFO.)|  
|01S02|Valore di opzione modificato|Il driver non supporta il valore specificato in *ValuePtr* o il valore specificato in *ValuePtr* non è valido a causa di condizioni di lavoro di implementazione, quindi il driver sostituisce un valore simile. È possibile chiamare **SQLGetStmtAttr** per determinare il valore temporaneamente sostituito. Il valore sostitutivo è valido per *statementHandle* fino a quando il cursore non viene chiuso, a quel punto l'attributo dell'istruzione ripristina il valore precedente. Gli attributi di istruzione che è possibile modificare sono:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La funzione restituisce SQL_SUCCESS_WITH_INFO.)|  
|08S01|Errore collegamento comunicazione|Il collegamento di comunicazione tra il driver e l'origine dati a cui è stato connesso il driver non è riuscito prima del completamento dell'elaborazione della funzione.|  
|24000|Stato del cursore non valido|L' *attributo* è SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS e il cursore è aperto.|  
|HY000|Errore generale:|Si è verificato un errore per il quale non esiste un valore SQLSTATE specifico e per il quale non è stato definito alcun valore SQLSTATE specifico dell'implementazione. Il messaggio di errore restituito da **SQLGetDiagRec** nel buffer *\* MessageText* descrive l'errore e la sua origine.|  
|HY001|Errore di allocazione della memoria|Il driver non è stato in grado di allocare memoria necessaria per supportare l'esecuzione o il completamento della funzione.|  
|HY009|Uso non valido del puntatore null|Nell'argomento *attribute* è stato identificato un attributo di istruzione che richiede un attributo stringa e l'argomento *ValuePtr* è un puntatore null.|  
|HY010|Errore sequenza funzione|(DM) è stata chiamata una funzione in esecuzione asincrona per l'handle di connessione associato a *statementHandle*. Questa funzione asincrona era ancora in esecuzione quando è stata chiamata la funzione **SQLSetStmtAttr** .<br /><br /> (DM) **SQLExecute**, **SQLExecDirect** o **SQLMoreResults** è stato chiamato per *statementHandle* e restituito SQL_PARAM_DATA_AVAILABLE. Questa funzione è stata chiamata prima del recupero dei dati per tutti i parametri trasmessi.<br /><br /> (DM) è stata chiamata una funzione in esecuzione asincrona per *statementHandle* ed è stata ancora eseguita quando è stata chiamata la funzione.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations** o **SQLSetPos** è stato chiamato per *statementHandle* e restituito SQL_NEED_DATA. Questa funzione è stata chiamata prima dell'invio dei dati per tutti i parametri o le colonne data-at-execution.|  
|HY011|Non è possibile impostare l'attributo adesso|L' *attributo* è stato SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR o SQL_ ATTR_USE_BOOKMARKS e l'istruzione è stata preparata.|  
|HY013|Errore di gestione della memoria|Impossibile elaborare la chiamata di funzione perché non è possibile accedere agli oggetti memoria sottostante, probabilmente a causa di condizioni di memoria insufficiente.|  
|HY017|Utilizzo non valido di un handle descrittore allocato automaticamente|(DM) l'argomento dell' *attributo* è stato SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) l'argomento dell' *attributo* è stato SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC e il valore in *ValuePtr* è un handle di descrittore allocato in modo implicito diverso dall'handle allocato originariamente per ARD o APD.|  
|HY024|Valore di attributo non valido|Dato il valore dell' *attributo* specificato, in *ValuePtr* è stato specificato un valore non valido. (Gestione driver restituisce questo valore SQLSTATE solo per gli attributi di connessione e di istruzione che accettano un set discreto di valori, ad esempio SQL_ATTR_ACCESS_MODE o SQL_ ATTR_ASYNC_ENABLE. Per tutti gli altri attributi di connessione e di istruzione, il driver deve verificare il valore specificato in *ValuePtr*.<br /><br /> L'argomento dell' *attributo* è SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC e *ValuePtr* è un handle di descrittore allocato in modo esplicito che non si trova nella stessa connessione dell'argomento *statementHandle* .|  
|HY090|Lunghezza della stringa o del buffer non valida|(DM) *\* ValuePtr* è una stringa di caratteri e l'argomento *StringLength* è minore di 0 ma non è stato SQL_NTS.|  
|HY092|Identificatore di attributo/opzione non valido|(DM) il valore specificato per l' *attributo* argument non era valido per la versione di ODBC supportata dal driver.<br /><br /> (DM) il valore specificato per l' *attributo* argument è un attributo di sola lettura.|  
|HY117|Connessione sospesa a causa di uno stato di transazione sconosciuto. Sono consentite solo le funzioni di disconnessione e di sola lettura.|(DM) per ulteriori informazioni sullo stato Suspended, vedere [funzione SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Funzionalità facoltativa non implementata|Il valore specificato per l' *attributo* argument è un attributo di istruzione ODBC valido per la versione di ODBC supportata dal driver ma non supportato dal driver.<br /><br /> L'argomento dell' *attributo* è stato SQL_ATTR_ASYNC_ENABLE e una chiamata a **SQLGetInfo** con un *InfoType* di SQL_ASYNC_MODE restituisce SQL_AM_CONNECTION.<br /><br /> L'argomento dell' *attributo* è stato SQL_ATTR_ENABLE_AUTO_IPD e il valore dell'attributo di connessione SQL_ATTR_AUTO_IPD è stato SQL_FALSE.|  
|HYT01|Timeout connessione scaduto|Il periodo di timeout della connessione è scaduto prima che l'origine dati abbia risposto alla richiesta. Il periodo di timeout della connessione viene impostato tramite **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Il driver non supporta questa funzione|(DM) il driver associato a *statementHandle* non supporta la funzione.|  
|S1118|Il driver non supporta la notifica asincrona|Se si chiama **SQLSetStmtAttr** per impostare SQL_ATTR_ASYNC_STMT_EVENT; la notifica asincrona non è supportata dal driver.|  
  
## <a name="comments"></a>Commenti  
 Gli attributi di istruzione per un'istruzione rimangono attivi fino a quando non vengono modificati da un'altra chiamata a **SQLSetStmtAttr** o fino a quando l'istruzione non viene eliminata chiamando **SQLFreeHandle**. La chiamata di **SQLFreeStmt** con l'opzione SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS non reimposta gli attributi dell'istruzione.  
  
 Alcuni attributi di istruzione supportano la sostituzione di un valore simile se l'origine dati non supporta il valore specificato in *ValuePtr*. In questi casi, il driver restituisce SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (il valore dell'opzione è stato modificato). Se, ad esempio, *attribute* è SQL_ATTR_CONCURRENCY e *ValuePtr* è SQL_CONCUR_ROWVER e se l'origine dati non supporta questa operazione, il driver sostituisce SQL_CONCUR_VALUES e restituisce SQL_SUCCESS_WITH_INFO. Per determinare il valore sostituito, un'applicazione chiama **SQLGetStmtAttr**.  
  
 Il formato delle informazioni impostate con *ValuePtr* dipende dall' *attributo* specificato. **SQLSetStmtAttr** accetta informazioni sugli attributi in uno dei due formati diversi, ovvero una stringa di caratteri o un valore integer. Il formato di ogni è indicato nella descrizione dell'attributo. Questo formato si applica alle informazioni restituite per ogni attributo in **SQLGetStmtAttr**. Le stringhe di caratteri a cui punta l'argomento *ValuePtr* di **SQLSetStmtAttr** hanno una lunghezza di *StringLength*.  
  
> [!NOTE]
>  La possibilità di impostare gli attributi di istruzione a livello di connessione chiamando **SQLSetConnectAttr** è stata deprecata in ODBC *3. x*. Le applicazioni ODBC *3. x* non devono mai impostare gli attributi di istruzione a livello di connessione. Non è possibile impostare gli attributi dell'istruzione ODBC *3. x* a livello di connessione, ad eccezione degli attributi SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, che sono sia attributi di connessione che attributi di istruzione, che possono essere impostati a livello di connessione o di istruzione.  
> 
> [!NOTE]
>  I driver ODBC *3. x* devono supportare questa funzionalità solo se dovrebbero funzionare con le applicazioni ODBC *2. x* che impostano le opzioni dell'istruzione ODBC *2. x* a livello di connessione. Per ulteriori informazioni, vedere "impostazione delle opzioni di istruzioni a livello di connessione" in [mapping di SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) in Appendice G: linee guida per la compatibilità con le versioni precedenti.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributi dell'istruzione che impostano i campi di descrizione  
 Molti attributi di istruzione corrispondono a un campo di intestazione di un descrittore. L'impostazione di questi attributi comporta effettivamente l'impostazione dei campi del descrittore. L'impostazione di campi mediante una chiamata a **SQLSetStmtAttr** anziché a **SQLSetDescField** offre il vantaggio di non dover ottenere un handle del descrittore per la chiamata di funzione.  
  
> [!CAUTION]  
>  La chiamata di **SQLSetStmtAttr** per un'istruzione può influire su altre istruzioni. Questo errore si verifica quando l'elemento APD o ARD associato all'istruzione viene allocato in modo esplicito ed è associato anche ad altre istruzioni. Poiché **SQLSetStmtAttr** modifica APD o ARD, le modifiche si applicano a tutte le istruzioni a cui è associato questo descrittore. Se questo non è il comportamento necessario, l'applicazione deve annullare l'associazione di questo descrittore dalle altre istruzioni (chiamando **SQLSetStmtAttr** per impostare il campo SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC su un handle descrittore diverso) prima di chiamare di nuovo **SQLSetStmtAttr** .  
  
 Quando un campo del descrittore viene impostato in seguito all'impostazione dell'attributo dell'istruzione corrispondente, il campo viene impostato solo per i descrittori applicabili attualmente associati all'istruzione identificata dall'argomento *statementHandle* e l'impostazione dell'attributo non influisce sui descrittori che potrebbero essere associati a tale istruzione in futuro. Quando un campo del descrittore che è anche un attributo di istruzione viene impostato da una chiamata a **SQLSetDescField**, viene impostato l'attributo dell'istruzione corrispondente. Se un descrittore allocato in modo esplicito viene dissociato da un'istruzione, un attributo di istruzione che corrisponde a un campo di intestazione verrà ripristinato al valore del campo nel descrittore allocato in modo implicito.  
  
 Quando un'istruzione viene allocata (vedere [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), i quattro handle descrittore vengono allocati automaticamente e associati all'istruzione. Gli handle descrittore allocati in modo esplicito possono essere associati all'istruzione chiamando **SQLAllocHandle** con un *fHandleType* di SQL_HANDLE_DESC per allocare un handle del descrittore e quindi chiamare **SQLSetStmtAttr** per associare l'handle del descrittore all'istruzione.  
  
 Gli attributi dell'istruzione nella tabella seguente corrispondono ai campi di intestazione del descrittore.  
  
|Attributo Statement|Campo di intestazione|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Attributi di istruzione  
 Nella tabella seguente sono illustrati gli attributi attualmente definiti e la versione di ODBC in cui sono stati introdotti. si prevede che un maggior numero di attributi verrà definito dai driver per sfruttare le diverse origini dati. Un intervallo di attributi è riservato da ODBC; gli sviluppatori di driver devono riservare i valori per l'uso specifico del driver da un gruppo aperto. Per ulteriori informazioni, vedere [tipi di dati specifici del driver, tipi di descrittori, tipi di informazioni, tipi di diagnostica e attributi](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attributo|Contenuto di *ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3,0)|Handle per l'oggetto APD per le successive chiamate a **SQLExecute** e **SQLExecDirect** nell'handle dell'istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito al momento dell'allocazione iniziale dell'istruzione. Se il valore di questo attributo è impostato su SQL_NULL_DESC o sull'handle allocato in origine per il descrittore, un handle APD allocato in modo esplicito precedentemente associato all'handle di istruzione viene annullato e l'handle di istruzione viene ripristinato all'handle APD allocato in modo implicito.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o per un altro handle del descrittore impostato in modo implicito nella stessa istruzione. gli handle descrittore allocati in modo implicito non possono essere associati a più di un'istruzione o un handle descrittore|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3,0)|Handle per ARD per i recuperi successivi nell'handle dell'istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito al momento dell'allocazione iniziale dell'istruzione. Se il valore di questo attributo è impostato su SQL_NULL_DESC o sull'handle allocato in origine per il descrittore, un handle ARD allocato in modo esplicito, precedentemente associato all'handle di istruzione, viene annullato e l'handle di istruzione viene ripristinato all'handle ARD allocato in modo implicito.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o per un altro handle del descrittore impostato in modo implicito nella stessa istruzione. gli handle descrittore allocati in modo implicito non possono essere associati a più di un'istruzione o un handle descrittore|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1,0)|Valore SQLULEN che specifica se una funzione chiamata con l'istruzione specificata viene eseguita in modo asincrono:<br /><br /> SQL_ASYNC_ENABLE_OFF = Disabilita il supporto dell'esecuzione asincrona a livello di istruzione (impostazione predefinita).<br /><br /> SQL_ASYNC_ENABLE_ON = Abilita supporto per l'esecuzione asincrona a livello di istruzione.<br /><br /> Per ulteriori informazioni, vedere [esecuzione asincrona (metodo di polling)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Per i driver con supporto dell'esecuzione asincrona a livello di istruzione, l'attributo Statement SQL_ATTR_ASYNC_ENABLE è di sola lettura. Il valore è uguale al valore dell'attributo a livello di connessione con lo stesso nome nel momento in cui è stato allocato l'handle dell'istruzione.<br /><br /> La chiamata a **SQLSetStmtAttr** per impostare SQL_ATTR_ASYNC_ENABLE quando il SQL_ASYNC_MODE *InfoType* restituisce SQL_AM_CONNECTION restituisce SQLSTATE HYC00 (funzionalità facoltativa non implementata). Per ulteriori informazioni, vedere la [funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) .|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3,8)|Valore SQLPOINTER che rappresenta un handle di evento.<br /><br /> La notifica del completamento delle funzioni asincrone viene abilitata chiamando **SQLSetStmtAttr** per impostare l'attributo **SQL_ATTR_ASYNC_STMT_EVENT** e specificare l'handle dell'evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3,8)|SQLPOINTER per la funzione di callback asincrona.<br /><br /> Solo Gestione driver può chiamare la funzione **SQLSetStmtAttr** di un driver con questo attributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3,8)|SQLPOINTER alla struttura del contesto<br /><br /> Solo Gestione driver può chiamare la funzione **SQLSetStmtAttr** di un driver con questo attributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2,0)|Valore SQLULEN che specifica la concorrenza del cursore:<br /><br /> SQL_CONCUR_READ_ONLY = il cursore è di sola lettura. Non sono consentiti aggiornamenti.<br /><br /> SQL_CONCUR_LOCK = il cursore utilizza il livello di blocco più basso sufficiente per garantire che la riga possa essere aggiornata.<br /><br /> SQL_CONCUR_ROWVER = il cursore usa il controllo della concorrenza ottimistica, confrontando le versioni di riga come SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = il cursore usa il controllo della concorrenza ottimistica, confrontando i valori.<br /><br /> Il valore predefinito per SQL_ATTR_CONCURRENCY è SQL_CONCUR_READ_ONLY.<br /><br /> Impossibile specificare questo attributo per un cursore aperto. Per altre informazioni, vedere [tipi di concorrenza](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se l' *attributo* SQL_ATTR_CURSOR_TYPE viene modificato in un tipo che non supporta il valore corrente di SQL_ATTR_CONCURRENCY, il valore di SQL_ATTR_CONCURRENCY verrà modificato in fase di esecuzione e verrà generato un avviso quando viene chiamato **SQLExecDirect** o **SQLPrepare** .<br /><br /> Se il driver supporta l'istruzione **Select for Update** e tale istruzione viene eseguita mentre il valore di SQL_ATTR_CONCURRENCY è impostato su SQL_CONCUR_READ_ONLY, verrà restituito un errore. Se il valore di SQL_ATTR_CONCURRENCY viene modificato in un valore supportato dal driver per un valore di SQL_ATTR_CURSOR_TYPE ma non per il valore corrente di SQL_ATTR_CURSOR_TYPE, il valore di SQL_ATTR_CURSOR_TYPE verrà modificato in fase di esecuzione e il valore SQLSTATE 01S02 (opzione modificata) viene emesso quando viene chiamato **SQLExecDirect** o **SQLPrepare** .<br /><br /> Se la concorrenza specificata non è supportata dall'origine dati, il driver sostituisce una concorrenza diversa e restituisce SQLSTATE 01S02 (il valore dell'opzione è stato modificato). Per SQL_CONCUR_VALUES, il driver sostituisce SQL_CONCUR_ROWVER e viceversa. Per SQL_CONCUR_LOCK, il driver sostituisce SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES in ordine. La validità del valore sostituito non viene controllata fino al momento dell'esecuzione.<br /><br /> Per ulteriori informazioni sulla relazione tra SQL_ATTR_CONCURRENCY e gli altri attributi del cursore, vedere [caratteristiche del cursore e tipo](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)di cursore.|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3,0)|Valore SQLULEN che specifica il livello di supporto necessario per l'applicazione. L'impostazione di questo attributo influiscono sulle chiamate successive a **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = i cursori scorrevoli non sono obbligatori nell'handle di istruzione. Se l'applicazione chiama **SQLFetchScroll** su questo handle, l'unico valore valido di *FetchOrientation* è SQL_FETCH_NEXT. Questo è il valore predefinito.<br /><br /> SQL_SCROLLABLE = i cursori scorrevoli sono obbligatori nell'handle di istruzione. Quando si chiama **SQLFetchScroll**, l'applicazione può specificare qualsiasi valore valido di *FetchOrientation*, ottenendo il posizionamento del cursore in modalità diverse dalla modalità sequenziale.<br /><br /> Per ulteriori informazioni sui cursori scorrevoli, vedere [cursori scorrevoli](../../../odbc/reference/develop-app/scrollable-cursors.md). Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_SCROLLABLE e gli altri attributi del cursore, vedere [caratteristiche del cursore e tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3,0)|Valore SQLULEN che specifica se i cursori nell'handle di istruzione rendono visibili le modifiche apportate a un set di risultati da un altro cursore. L'impostazione di questo attributo influiscono sulle chiamate successive a **SQLExecDirect** e **SQLExecute**. Un'applicazione può leggere il valore di questo attributo per ottenere lo stato iniziale o il relativo stato come impostato più di recente dall'applicazione.<br /><br /> SQL_UNSPECIFIED = non è specificato il tipo di cursore e indica se i cursori nell'handle di istruzione rendono visibili le modifiche apportate a un set di risultati da un altro cursore. I cursori nell'handle dell'istruzione possono rendere visibile nessuno, alcune o tutte le modifiche. Questo è il valore predefinito.<br /><br /> SQL_INSENSITIVE = tutti i cursori nell'handle di istruzione visualizzano il set di risultati senza riflettere le modifiche apportate da altri cursori. I cursori non sensibili sono di sola lettura. Corrisponde a un cursore statico, che dispone di una concorrenza di sola lettura.<br /><br /> SQL_SENSITIVE = tutti i cursori nell'handle di istruzione rendono visibili tutte le modifiche apportate a un set di risultati da un altro cursore.<br /><br /> Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_SENSITIVITY e gli altri attributi del cursore, vedere [caratteristiche del cursore e tipo](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)di cursore.|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2,0)|Valore SQLULEN che specifica il tipo di cursore:<br /><br /> SQL_CURSOR_FORWARD_ONLY = il cursore scorre in futuro.<br /><br /> SQL_CURSOR_STATIC = i dati nel set di risultati sono statici.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = il driver Salva e utilizza le chiavi per il numero di righe specificato nell'attributo SQL_ATTR_KEYSET_SIZE istruzione.<br /><br /> SQL_CURSOR_DYNAMIC = il driver Salva e utilizza solo le chiavi per le righe nel set di righe.<br /><br /> Il valore predefinito è SQL_CURSOR_FORWARD_ONLY. Questo attributo non può essere specificato dopo che l'istruzione SQL è stata preparata.<br /><br /> Se il tipo di cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo di cursore diverso e restituisce SQLSTATE 01S02 (il valore dell'opzione è stato modificato). Per un cursore misto o dinamico, il driver sostituisce in ordine un cursore statico o gestito da keyset. Per un cursore gestito da keyset, il driver sostituisce un cursore statico.<br /><br /> Per ulteriori informazioni sui tipi di cursore scorrevoli, vedere [tipi di cursori scorrevoli](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_TYPE e gli altri attributi del cursore, vedere [caratteristiche del cursore e tipo](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)di cursore.|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3,0)|Valore SQLULEN che specifica se viene eseguito il popolamento automatico del dip:<br /><br /> SQL_TRUE = attiva il popolamento automatico del dip dopo una chiamata a **SQLPrepare**. SQL_FALSE = disattiva il popolamento automatico del dip dopo una chiamata a **SQLPrepare**. Un'applicazione può comunque ottenere informazioni sui campi di dpi chiamando **SQLDescribeParam**, se supportata. Il valore predefinito dell'attributo Statement SQL_ATTR_ENABLE_AUTO_IPD è SQL_FALSE. Per altre informazioni, vedere [popolamento automatico del dip](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3,0)|Oggetto SQLLEN \* che punta a un valore di segnalibro binario. Quando **SQLFetchScroll** viene chiamato con *fFetchOrientation* uguale a SQL_FETCH_BOOKMARK, il driver preleva il valore del segnalibro da questo campo. Il valore predefinito di questo campo è un puntatore null. Per ulteriori informazioni, vedere [scorrimento in base al segnalibro](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Il valore a cui fa riferimento questo campo non viene utilizzato per le operazioni DELETE by Bookmark, Update by Bookmark o FETCH by Bookmark in **SQLBulkOperations**, che utilizzano segnalibri memorizzati nella cache nei buffer del set di righe.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3,0)|Handle per l'oggetto dpi. Il valore di questo attributo è il descrittore allocato al momento dell'allocazione iniziale dell'istruzione. L'applicazione non è in grado di impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** , ma non da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3,0)|Handle per IRD. Il valore di questo attributo è il descrittore allocato al momento dell'allocazione iniziale dell'istruzione. L'applicazione non è in grado di impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** , ma non da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2,0)|Oggetto SQLULEN che specifica il numero di righe nel keyset per un cursore gestito da keyset. Se la dimensione del keyset è 0 (impostazione predefinita), il cursore è completamente gestito da keyset. Se le dimensioni del keyset sono maggiori di 0, il cursore è misto (gestito da keyset all'interno del keyset e dinamico all'esterno del keyset). Le dimensioni predefinite del keyset sono pari a 0. Per ulteriori informazioni sui cursori gestiti da keyset, vedere [cursori gestiti da keyset](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Se le dimensioni specificate superano le dimensioni massime del keyset, il driver sostituisce tale dimensione e restituisce SQLSTATE 01S02 (il valore dell'opzione è stato modificato).<br /><br /> **SQLFetch** o **SQLFetchScroll** restituisce un errore se le dimensioni del keyset sono maggiori di 0 e minori delle dimensioni del set di righe.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1,0)|Valore SQLULEN che specifica la quantità massima di dati restituiti dal driver da una colonna di tipo carattere o binario. Se *ValuePtr* è inferiore alla lunghezza dei dati disponibili, **SQLFetch** o **SQLGetData** tronca i dati e restituisce SQL_SUCCESS. Se *ValuePtr* è 0 (impostazione predefinita), il driver tenta di restituire tutti i dati disponibili.<br /><br /> Se la lunghezza specificata è inferiore alla quantità minima di dati che l'origine dati può restituire o superiore alla quantità massima di dati che l'origine dati può restituire, il driver sostituisce tale valore e restituisce SQLSTATE 01S02 (valore opzione modificata).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non essere applicata immediatamente, nel qual caso il driver restituirà SQLSTATE 01S02 (valore di opzione modificato) e Reimposta l'attributo sul valore originale.<br /><br /> Questo attributo è progettato per ridurre il traffico di rete e deve essere supportato solo quando l'origine dati (in contrapposizione al driver) in un driver a più livelli può implementarla. Questo meccanismo non deve essere utilizzato dalle applicazioni per troncare i dati. per troncare i dati ricevuti, un'applicazione deve specificare la lunghezza massima del buffer nell'argomento *bufferLength* in **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1,0)|Valore SQLULEN che corrisponde al numero massimo di righe da restituire all'applicazione per un'istruzione **Select** . Se \* *ValuePtr* è uguale a 0 (impostazione predefinita), il driver restituisce tutte le righe.<br /><br /> Questo attributo è progettato per ridurre il traffico di rete. Concettualmente, viene applicato quando viene creato il set di risultati e limita il set di risultati alle prime righe *ValuePtr* . Se il numero di righe nel set di risultati è maggiore di *ValuePtr*, il set di risultati viene troncato.<br /><br /> SQL_ATTR_MAX_ROWS si applica a tutti i set di risultati nell' *istruzione*, inclusi quelli restituiti dalle funzioni di catalogo. SQL_ATTR_MAX_ROWS stabilisce un valore massimo per il valore del conteggio delle righe del cursore.<br /><br /> Un driver non deve emulare SQL_ATTR_MAX_ROWS comportamento per **SQLFetch** o **SQLFetchScroll** (se non è possibile implementare limitazioni delle dimensioni del set di risultati nell'origine dati) se non è in grado di garantire che SQL_ATTR_MAX_ROWS venga implementato correttamente.<br /><br /> Viene definito dal driver se SQL_ATTR_MAX_ROWS si applica a istruzioni diverse dalle istruzioni SELECT, ad esempio le funzioni di catalogo.<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non essere applicata immediatamente, nel qual caso il driver restituirà SQLSTATE 01S02 (valore di opzione modificato) e Reimposta l'attributo sul valore originale.|  
|SQL_ATTR_METADATA_ID (ODBC 3,0)|Valore SQLULEN che determina il modo in cui vengono gestiti gli argomenti di stringa delle funzioni di catalogo.<br /><br /> Se SQL_TRUE, l'argomento di stringa delle funzioni di catalogo viene considerato come identificatori. Il caso non è significativo. Per le stringhe non delimitate, il driver rimuove tutti gli spazi finali e la stringa viene riflessa in maiuscolo. Per le stringhe delimitate, il driver rimuove tutti gli spazi iniziali o finali e prende il valore che intercorre tra i delimitatori. Se uno di questi argomenti è impostato su un puntatore null, la funzione restituisce SQL_ERROR e SQLSTATE HY009 (utilizzo non valido del puntatore null).<br /><br /> Se SQL_FALSE, gli argomenti di stringa delle funzioni di catalogo non vengono considerati come identificatori. Il caso è significativo. Possono contenere un criterio di ricerca di stringhe o meno, a seconda dell'argomento.<br /><br /> Il valore predefinito è SQL_FALSE.<br /><br /> L'argomento *TableType* di **SQLTables**, che accetta un elenco di valori, non è influenzato da questo attributo.<br /><br /> È possibile impostare SQL_ATTR_METADATA_ID anche a livello di connessione. (It e SQL_ATTR_ASYNC_ENABLE sono gli unici attributi di istruzione che sono anche attributi di connessione).<br /><br /> Per ulteriori informazioni, vedere [arguments in Catalog Functions](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1,0)|Valore SQLULEN che indica se il driver deve eseguire l'analisi delle stringhe SQL per le sequenze di escape:<br /><br /> SQL_NOSCAN_OFF = il driver analizza le stringhe SQL per le sequenze di escape (impostazione predefinita).<br /><br /> SQL_NOSCAN_ON = il driver non esegue l'analisi delle stringhe SQL per le sequenze di escape. Al contrario, il driver invia l'istruzione direttamente all'origine dati.<br /><br /> Per ulteriori informazioni, vedere [sequenze di escape in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3,0)|Valore SQLULEN * che punta a un offset aggiunto ai puntatori per modificare l'associazione di parametri dinamici. Se questo campo è diverso da null, il driver dereferenzia il puntatore, aggiunge il valore dereferenziato a ognuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa i nuovi valori del puntatore durante l'associazione. Per impostazione predefinita, è impostato su null.<br /><br /> L'offset di binding viene sempre aggiunto direttamente ai campi SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se l'offset viene impostato su un valore diverso, il nuovo valore viene ancora aggiunto direttamente al valore nel campo del descrittore. Il nuovo offset non viene aggiunto al valore del campo più gli offset precedenti.<br /><br /> Per altre informazioni, vedere [offset dell'associazione di parametri](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3,0)|Valore SQLULEN che indica l'orientamento dell'associazione da utilizzare per i parametri dinamici.<br /><br /> Questo campo è impostato su SQL_PARAM_BIND_BY_COLUMN (impostazione predefinita) per selezionare l'associazione per colonna.<br /><br /> Per selezionare l'associazione per riga, questo campo è impostato sulla lunghezza della struttura o su un'istanza di un buffer che verrà associato a un set di parametri dinamici. Questa lunghezza deve includere lo spazio per tutti i parametri associati e qualsiasi riempimento della struttura o del buffer per garantire che quando l'indirizzo di un parametro associato venga incrementato con la lunghezza specificata, il risultato punterà all'inizio dello stesso parametro nel set di parametri successivo. Quando si usa l'operatore *sizeof* in ANSI C, questo comportamento è garantito.<br /><br /> Per ulteriori informazioni, vedere [binding di matrici di parametri](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_ BIND_TYPE nell'intestazione APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3,0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT utilizzati per ignorare un parametro durante l'esecuzione di un'istruzione SQL. Ogni valore è impostato su SQL_PARAM_PROCEED (per il parametro da eseguire) o SQL_PARAM_IGNORE (per il parametro da ignorare).<br /><br /> Un set di parametri può essere ignorato durante l'elaborazione impostando il valore di stato nella matrice a cui punta SQL_DESC_ARRAY_STATUS_PTR nell'APD per SQL_PARAM_IGNORE. Un set di parametri viene elaborato se il relativo valore di stato è impostato su SQL_PARAM_PROCEED o se non sono impostati elementi nella matrice.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato dei parametri. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva chiamata a **SQLExecDirect** o **SQLExecute** .<br /><br /> Questo attributo viene ignorato quando non è presente alcun parametro associato.<br /><br /> Per ulteriori informazioni, vedere [utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3,0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT contenenti informazioni sullo stato per ogni riga di valori di parametro dopo una chiamata a **SQLExecute** o **SQLExecDirect**. Questo campo è obbligatorio solo se PARAMSET_SIZE è maggiore di 1.<br /><br /> I valori di stato possono contenere i valori seguenti:<br /><br /> SQL_PARAM_SUCCESS: l'istruzione SQL è stata eseguita correttamente per questo set di parametri.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: l'istruzione SQL è stata eseguita correttamente per questo set di parametri. Tuttavia, le informazioni sugli avvisi sono disponibili nella struttura dei dati di diagnostica.<br /><br /> SQL_PARAM_ERROR: si è verificato un errore durante l'elaborazione di questo set di parametri. Informazioni aggiuntive sull'errore sono disponibili nella struttura dei dati di diagnostica.<br /><br /> SQL_PARAM_UNUSED: questo set di parametri è stato inutilizzato, probabilmente a causa del fatto che alcuni set di parametri precedenti hanno causato un errore che ha interrotto l'ulteriore elaborazione o perché SQL_PARAM_IGNORE è stato impostato per il set di parametri nella matrice specificata dal SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: il driver considera le matrici di parametri come unità monolitica e pertanto non genera questo livello di informazioni sugli errori.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato dei parametri. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva chiamata a **SQLExecute** o **SQLExecDirect** . Si noti che l'impostazione di questo attributo può influire sul comportamento del parametro di output implementato dal driver.<br /><br /> Per ulteriori informazioni, vedere [utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione dpi.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3,0)|Campo di \* record SQLULEN che punta a un buffer in cui restituire il numero di set di parametri elaborati, inclusi i set di errori. Se questo è un puntatore null, non verrà restituito alcun numero.<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione dpi.<br /><br /> Se la chiamata a **SQLExecDirect** o **SQLExecute** che compila il buffer a cui punta questo attributo non restituisce SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.<br /><br /> Per ulteriori informazioni, vedere [utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3,0)|Valore SQLULEN che specifica il numero di valori per ogni parametro. Se SQL_ATTR_PARAMSET_SIZE è maggiore di 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR del punto di APD a matrici. La cardinalità di ogni matrice è uguale al valore di questo campo.<br /><br /> Questo attributo viene ignorato quando non è presente alcun parametro associato.<br /><br /> Per ulteriori informazioni, vedere [utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1,0)|Valore SQLULEN che corrisponde al numero di secondi di attesa per l'esecuzione di un'istruzione SQL prima di tornare all'applicazione. Se *ValuePtr* è uguale a 0 (impostazione predefinita), non è previsto alcun timeout.<br /><br /> Se il timeout specificato supera il timeout massimo nell'origine dati o è inferiore al timeout minimo, **SQLSetStmtAttr** sostituisce tale valore e restituisce SQLSTATE 01S02 (il valore dell'opzione è stato modificato).<br /><br /> Si noti che l'applicazione non deve chiamare **SQLCloseCursor** per riutilizzare l'istruzione se si è verificato il timeout di un'istruzione **SELECT** .<br /><br /> Il timeout della query impostato in questo attributo dell'istruzione è valido in modalità sincrona e asincrona.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2,0)|Valore SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, in ODBC *3. x*, **SQLFetch** recupera i dati dopo aver posizionato il cursore nella posizione specificata. Questo è il valore predefinito.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, in ODBC *3. x*, **SQLFetch** non recupera i dati dopo aver posizionato il cursore.<br /><br /> Impostando SQL_RETRIEVE_DATA su SQL_RD_OFF, un'applicazione può verificare l'esistenza di una riga o recuperare un segnalibro per la riga senza incorrere nel sovraccarico del recupero delle righe. Per altre informazioni, vedere [scorrimento e recupero di righe](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non essere applicata immediatamente, nel qual caso il driver restituirà SQLSTATE 01S02 (valore di opzione modificato) e Reimposta l'attributo sul valore originale.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3,0)|Valore SQLULEN che specifica il numero di righe restituite da ogni chiamata a **SQLFetch** o **SQLFetchScroll**. È anche il numero di righe in una matrice di segnalibri utilizzato in un'operazione di segnalibro bulk in **SQLBulkOperations**. Il valore predefinito è 1.<br /><br /> Se le dimensioni del set di righe specificato superano le dimensioni massime del set di righe supportate dall'origine dati, il driver sostituisce tale valore e restituisce il valore SQLSTATE 01S02 (opzione modificata).<br /><br /> Per ulteriori informazioni, vedere [dimensioni del set di righe](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3,0)|Valore SQLULEN * che punta a un offset aggiunto ai puntatori per modificare il binding dei dati della colonna. Se questo campo è diverso da null, il driver dereferenzia il puntatore, aggiunge il valore dereferenziato a ognuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e usa i nuovi valori del puntatore durante l'associazione. Per impostazione predefinita, è impostato su null.<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1,0)|Valore SQLULEN che imposta l'orientamento dell'associazione da utilizzare quando **SQLFetch** o **SQLFetchScroll** viene chiamato sull'istruzione associata. L'associazione per colonna viene selezionata impostando il valore su SQL_BIND_BY_COLUMN. L'associazione per riga viene selezionata impostando il valore sulla lunghezza di una struttura o di un'istanza di un buffer in cui verranno associato le colonne di risultati.<br /><br /> Se viene specificata una lunghezza, deve includere lo spazio per tutte le colonne associate e qualsiasi riempimento della struttura o del buffer per garantire che, quando l'indirizzo di una colonna associata viene incrementato con la lunghezza specificata, il risultato punterà all'inizio della stessa colonna nella riga successiva. Quando si utilizza l'operatore **sizeof** con strutture o unioni in ANSI C, questo comportamento è garantito.<br /><br /> L'associazione per colonna è l'orientamento di associazione predefinito per **SQLFetch** e **SQLFetchScroll**.<br /><br /> Per ulteriori informazioni, vedere [binding di colonne da utilizzare con cursori a blocchi](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> L'impostazione di questo attributo dell'istruzione imposta il campo SQL_DESC_BIND_TYPE nell'intestazione ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2,0)|Valore SQLULEN che rappresenta il numero della riga corrente nell'intero set di risultati. Se non è possibile determinare il numero della riga corrente o se non è presente alcuna riga corrente, il driver restituirà 0.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** , ma non da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3,0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT utilizzati per ignorare una riga durante un'operazione bulk utilizzando **SQLSetPos**. Ogni valore è impostato su SQL_ROW_PROCEED (per la riga da includere nell'operazione bulk) o SQL_ROW_IGNORE (per la riga da escludere dall'operazione bulk). Non è possibile ignorare le righe utilizzando questa matrice durante le chiamate a **SQLBulkOperations**.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato della riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene usato fino alla successiva chiamata a **SQLSetPos** .<br /><br /> Per ulteriori informazioni, vedere [aggiornamento di righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) ed [eliminazione di righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR in ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3,0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT contenenti valori di stato della riga dopo una chiamata a **SQLFetch** o **SQLFetchScroll**. Il numero di elementi della matrice è il numero di righe nel set di righe.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato della riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva chiamata a **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll** o **SQLSetPos** .<br /><br /> Per ulteriori informazioni, vedere il [numero di righe recuperate e lo stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> L'impostazione di questo attributo di istruzione consente di impostare il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IRD.<br /><br /> Questo attributo viene mappato da un driver ODBC *2. x* alla matrice *rgbRowStatus* in una chiamata a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3,0)|Valore SQLULEN \* che punta a un buffer in cui restituire il numero di righe recuperate dopo una chiamata a **SQLFetch** o **SQLFetchScroll**, il numero di righe interessate da un'operazione bulk eseguita da una chiamata a **SQLSetPos** con un argomento *Operation* di SQL_REFRESH o il numero di righe interessate da un'operazione bulk eseguita da **SQLBulkOperations**. Questo numero include righe di errore.<br /><br /> Per ulteriori informazioni, vedere il [numero di righe recuperate e lo stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> L'impostazione di questo attributo di istruzione consente di impostare il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IRD.<br /><br /> Se la chiamata a **SQLFetch** o **SQLFetchScroll** che compila il buffer a cui punta questo attributo non restituisce SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2,0)|Valore SQLULEN che specifica se i driver che simulano istruzioni Update e Delete posizionate garantiscono che tali istruzioni influiscano su una sola riga.<br /><br /> Per simulare le istruzioni Update e Delete posizionate, la maggior parte dei driver crea un'istruzione **Update** o **Delete** con una clausola **where** che specifica il valore di ogni colonna nella riga corrente. A meno che tali colonne non compongono una chiave univoca, tale istruzione può interessare più di una riga.<br /><br /> Per garantire che tali istruzioni influiscano su una sola riga, il driver determina le colonne in una chiave univoca e aggiunge tali colonne al set di risultati. Se un'applicazione garantisce che le colonne del set di risultati compongono una chiave univoca, non è necessario che il driver esegua questa operazione. Questo può ridurre il tempo di esecuzione.<br /><br /> SQL_SC_NON_UNIQUE = il driver non garantisce che le istruzioni Update o DELETE posizionate in simulate influirà su una sola riga. Questa operazione è responsabilità dell'applicazione. Se un'istruzione ha effetto su più di una riga, **SQLExecute**, **SQLExecDirect** o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto di operazione del cursore).<br /><br /> SQL_SC_TRY_UNIQUE = il driver tenta di garantire che le istruzioni Update o DELETE posizionate in simulate influiscano su una sola riga. Il driver esegue sempre tali istruzioni, anche se possono interessare più di una riga, ad esempio quando non è presente alcuna chiave univoca. Se un'istruzione ha effetto su più di una riga, **SQLExecute**, **SQLExecDirect** o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto di operazione del cursore).<br /><br /> SQL_SC_UNIQUE = il driver garantisce che le istruzioni Update o DELETE posizionate in modo simulato influiscano solo su una riga. Se il driver non è in grado di garantire questa condizione per un'istruzione specificata, **SQLExecDirect** o **SQLPrepare** restituisce un errore.<br /><br /> Se l'origine dati fornisce il supporto SQL nativo per le istruzioni Update e Delete posizionate e il driver non simula i cursori, SQL_SUCCESS viene restituito quando viene richiesto SQL_SC_UNIQUE per SQL_SIMULATE_CURSOR. Se viene richiesto SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE, viene restituito SQL_SUCCESS_WITH_INFO. Se l'origine dati fornisce il SQL_SC_TRY_UNIQUE livello di supporto e il driver non lo è, viene restituito SQL_SUCCESS per SQL_SC_TRY_UNIQUE e viene restituito SQL_SUCCESS_WITH_INFO per SQL_SC_NON_UNIQUE.<br /><br /> Se il tipo di simulazione del cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo di simulazione diverso e restituisce SQLSTATE 01S02 (il valore dell'opzione è stato modificato). Per SQL_SC_UNIQUE, il driver sostituisce SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE in ordine. Per SQL_SC_TRY_UNIQUE, il driver sostituisce SQL_SC_NON_UNIQUE.<br /><br /> Il valore predefinito è SQL_SC_UNIQUE.<br /><br /> Per ulteriori informazioni, vedere [simulazione di istruzioni Update e Delete posizionate](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2,0)|Valore SQLULEN che specifica se un'applicazione utilizzerà segnalibri con un cursore:<br /><br /> SQL_UB_OFF = disattivato (impostazione predefinita)<br /><br /> SQL_UB_VARIABLE = un'applicazione utilizzerà segnalibri con un cursore e il driver fornirà segnalibri a lunghezza variabile se supportati. SQL_UB_FIXED è deprecato in ODBC *3. x*. Le applicazioni ODBC *3. x* devono utilizzare sempre segnalibri a lunghezza variabile, anche quando si utilizzano driver ODBC *2. x* (che supportano solo segnalibri a lunghezza fissa a 4 byte). Questo perché un segnalibro a lunghezza fissa è solo un caso speciale di un segnalibro a lunghezza variabile. Quando si utilizza un driver ODBC *2. x* , gestione driver esegue il mapping SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Per usare i segnalibri con un cursore, l'applicazione deve specificare questo attributo con il valore SQL_UB_VARIABLE prima di aprire il cursore.<br /><br /> Per altre informazioni, vedere [recupero di segnalibri](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] queste funzioni possono essere chiamate in modo asincrono solo se il descrittore è un descrittore di implementazione, non un descrittore di applicazione.  
  
 Vedere [associazione per colonna](../../../odbc/reference/develop-app/column-wise-binding.md) e [associazione per riga](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funzioni correlate  
  
|Per informazioni su|Vedere|  
|---------------------------|---------|  
|Annullamento dell'elaborazione di istruzioni|[Funzione SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Restituzione dell'impostazione di un attributo di connessione|[Funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Restituzione dell'impostazione di un attributo di istruzione|[Funzione SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Impostazione di un attributo di connessione|[Pagina relativa alla funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Impostazione di un singolo campo del descrittore|[Funzione SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vedere anche  
 [Informazioni di riferimento sulle API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [File di intestazione ODBC](../../../odbc/reference/install/odbc-header-files.md)
